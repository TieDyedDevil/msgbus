/*
	Publish/subscribe message bus using 0MQ's ZRE protocol.
	February 2020
	ADIDRUS project
	Galois, Inc.
*/

#ifndef _MSGBUS_H_
#define _MSGBUS_H_

#include "zyre.h"
#include "zyre_event.h"

/* Internal errors are logged to standard output. You can change this
   using zsys_set_logstream(); this affects all 0MQ clients in the process. */

/* Callback upon receipt of messages, both administrative and content.
	name: Local node name
	type: ENTER, EXIT, JOIN, LEAVE, EVASIVE (admin); SHOUT, WHISPER (data)
	peer: Peer node name (not guaranteed unique)
	peer_uuid: Peer node UUID
	topic: Topic name
   userptr: passthru from msgbus_open
	msg_text: Payload (owned by the caller, free'd after the call)
   The topic and msg_text are NULL for administrative messages.
   A WHISPER message denotes a point-to-point communication; this is never
    generated by this library, but could be inserted by other ZRE clients. */
typedef void (*msgbus_callback_t)(const char *name, const char *type,
		const char *peer, const char *peer_uuid, const char *topic,
      void *userptr, const char *msg_text);

/* The port must be capable of passing UDP traffic. This is used for peer
    discovery. Port 5670 is registered with IANA for this purpose. The
    range of privileged port numbers (0..1023) is disallowed.
   The name is passed to subscribers as the peer name.
   The interface is the name of the network interface over which both
    discovery and message traffic flows. If specified as NULL, the library
    will pick an interface which supports broadcast addressing; this should
    be used *only* on hosts for which this choice will ensure that the
    proper subnet is used. (IOW, if the host has interfaces on different
    subnets, you should name the desired interface.)
   The list of topics to subscribe to is a NULL-terminated array.
   The callback is the handler called for received messages.
   The userptr is passed through to the callback for client tagging/use.
   IMPORTANT: The bus is NOT immediately usable upon return. Use a short
    sleep (e.g. zclock_sleep(100)) before publishing the first message.
   Returns a handle to pass to msgbus_publish() and msgbus_close(). */
zactor_t *msgbus_open(int port, const char *name, const char *interface,
                      const char *topics[], msgbus_callback_t callback,
                      void *userptr);

/* Messages published to a nonexistent subscriber disappear without notice.
   Other errors return nonzero status.
   A publisher never receives its own messages. */
int msgbus_publish(zactor_t *handle, const char *topic, const char *message);

/* Shut down the message bus for the current process.
   Set the handle to NULL.
   IMPORTANT: Pending messages are lost when closing the bus.
   Return 0 on success. */
int msgbus_close(zactor_t **handle);

#endif
